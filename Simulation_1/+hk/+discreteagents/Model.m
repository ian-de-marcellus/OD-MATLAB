classdef (Abstract) Model < hk.Model
    % MODEL - HK Model with discrete agents superclass

    properties (SetAccess = protected, GetAccess = public)
        % NAGENTS - total number of agents
        % In zealot model includes both zealots and persuadables
        nAgents {mustBePositive, mustBeInteger}

        initialOpinionArray(1,:)  % opinion values at time=1
        initialAdjacencyMatrix(:,:)  % adjacency matrix user passed in

        % BOUNDS - agent confidence bounds
        % In heterogeneous models, array of bounds
        % In zealot and homogenous models, bound value
        % Every value must be nonnegative
        bound 
    end

    properties (Access = protected)
        % ADJACENCYMATRIX - adjacency matrix between agents
        % The input is modified such that each agent is adjacent to itself,
        % to simplify calculations
        adjacencyMatrix(:,:)

        % DISTANCEMATRIX - pairwise distances between agents
        % Updated each timestep
        % distanceMatrix(:,:)  % TODO: do I need this?

        % INDICATORMATRIX - whether two agents influence each other
        % A 1 indicates that the corresponding agents are adjacent and are
        % close enough to influence each other, 0 otherwise
        % Updated each timestep
        % indicatorMatrix(:,:)  % TODO: do I need this?

        currentOpinionArray(1,:)  % opinion values at current timestep

        % SIMULATIONDATAMATRIX - opinion values at all timesteps
        % Each row corresponds to a different agent
        % Each column corresponds to a different timestep
        simulationDataMatrix(:,:)  % opinion values at all timesteps
    end

    properties (Abstract, Access = protected)
        % ENFORCESELFADJACENCY - enforce all 1s on main diagonal of adjacency
        % Subclasses should set true by default
        enforceSelfAdjacency
    end

    methods
        function self = Model(opinionArray, adjacencyMatrix, bound, timestep)
            % DISCRETEAGENTS - Abstract class: HKModel with discrete agents

            % validate input
            assert(~diff(size(adjacencyMatrix)), "Adjacency matrix must be square.")
            assert(length(opinionArray) == length(adjacencyMatrix), ...
                "Opinion array length and adjacency matrix dimensions must match.")
            assert(length(bound) == length(opinionArray) || length(bound) == 1, ...
                "Bound must be an array with same length as opinionArray or a scalar.")

            self@hk.Model(timestep)
            
            self.bound = bound;
            self.initialOpinionArray = opinionArray;
            self.currentOpinionArray = opinionArray;
            self.initialAdjacencyMatrix = adjacencyMatrix;
            self.nAgents = length(opinionArray);

            if (self.enforceSelfAdjacency)
                self.adjacencyMatrix = hk.Statics.forceselfadjacency(adjacencyMatrix);
            else
                self.adjacencyMatrix = adjacencyMatrix;
            end

            self.simulationDataMatrix(:,1) = opinionArray;
        end

        function data = getdata(self)
            % GETDATA - returns data currently generated by simulation
            % Each row corresponds to a different agent
            % Each column corresponds to a different timestep
            data = self.simulationDataMatrix;
        end
    end

%     methods(Access = public)
%         function outputMatrix = forceselfadjacency(inputMatrix)
%             % FORCESELFADJACENCY - sets main diagonal to 1s
%             % Takes in matrix, sets main diagonal to 1s regardless of
%             % previous values
%             initialMainDiagonal = diag(inputMatrix);
%             outputMatrix = inputMatrix - initialMainDiagonal + eye(size(inputMatrix));
%         end
% 
%         function distMatr = distanceMatrix(array)
%             % DISTANCE finds pairwise distances between array values
%             % uses .' to transpose the opinion array
%             distMatr = abs(array - array.');
%         end
%     end

    methods (Abstract, Access = protected)
        newOpinions = updateopinions(oldOpinions, influenceMatrix)
    end

    methods (Access = protected)
        function diff = lastopiniondifferential(self)
            % LASTOPINIONDIFFERENTIAL - error estimate
            % Sum of (absolute) differences in opinions between the current timestep
            % and the previous timestep
            if (self.frame == 1)
                % if frame is 1, there's no last step to compare to
                diff = NaN;
            else
                opinions = self.simulationDataMatrix;
                diff = sum(abs(opinions(:, self.frame)-opinions(:, self.frame-1)));
            end
        end
    end
end