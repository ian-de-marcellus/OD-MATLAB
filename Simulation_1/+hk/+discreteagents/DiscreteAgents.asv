classdef (Abstract) DiscreteAgents < hkmodel.HKBoundedConfidenceModel
    % DISCRETEAGENTS Superclass for HK bounded confidence models w discrete
    % agents

    properties (SetAccess = protected, GetAccess = public)
        % NAGENTS - total number of agents
        % In zealot model includes both zealots and persuadables
        nAgents {mustBePositive, mustBeInteger}

        initialOpinionArray(1,:)  % opinion values at time=1
        initialAdjacencyMatrix(:,:)  % adjacency matrix user passed in

        % BOUNDS - agent confidence bounds
        % In heterogeneous models, array of bounds
        % In zealot and homogenous models, bound value
        % Every value must be nonnegative
        bound 
    end

    properties (Access = protected)
        % ADJACENCYMATRIX - adjacency matrix between agents
        % The input is modified such that each agent is adjacent to itself,
        % to simplify calculations
        adjacencyMatrix(:,:)

        % DISTANCEMATRIX - pairwise distances between agents
        % Updated each timestep
        distanceMatrix(:,:)

        % INDICATORMATRIX - whether two agents influence each other
        % A 1 indicates that the corresponding agents are adjacent and are
        % close enough to influence each other, 0 otherwise
        % Updated each timestep
        indicatorMatrix(:,:)

        currentOpinionArray(1,:)  % opinion values at current timestep

        % SIMULATIONDATAMATRIX - opinion values at all timesteps
        % Each row corresponds to a different agent
        % Each column corresponds to a different timestep
        simulationDataMatrix(:,:)  % opinion values at all timesteps
        
        % SELFADJACENCY - enforce all 1s on main diagonal of adjacency
        % On by default, but allows overriding of condition in future
        % subclasses
        enforceSelfAdjacency = true
    end

    methods
        function self = DiscreteAgents(timestep, bounds, opinionArray, adjacencyMatrix, selfAdjacent)
            % DISCRETEAGENTS - Abstract class: HKModel with discrete agents

            % validate input
            assert(~diff(size(adjacencyMatrix)), "Adjacency matrix must be square.")
            assert(length(opinionArray) == length(adjacencyMatrix), ...
                "Opinion array length and adjacency matrix dimensions must match.")

            self@hkmodel.HKBoundedConfidenceModel(timestep)
            
            self.bound = bounds;
            self.initialOpinionArray = opinionArray;
            self.initialAdjacencyMatrix = adjacencyMatrix;
            self.nAgents = length(opinionArray);
            self.enforceSelfAdjacency = selfAdjacent;

            if (self.enforceSelfAdjacency)
                self.adjacencyMatrix = forceselfadjacency(adjacencyMatrix);
            else
                self.adjacencyMatrix = adjacencyMatrix;
            end

            self.simulationDataMatrix(1,:) = opinionArray;
        end

        function data = getdata(self)
            % GETDATA - returns data currently generated by simulation
            % Each row corresponds to a different agent
            % Each column corresponds to a different timestep
            data = self.simulationDataMatrix;
        end

        function simulatesteps(self, steps)
            for i = 2:steps
                % set distance and indicator matrices
                self.updatecoefficients();
                
                self.currentOpinionArray = step(self);
                self.simulationDataMatrix(i,:) = self.currentOpinionArray;
            end

        end
    end

    methods(Static)
        function outputMatrix = forceselfadjacency(inputMatrix)
            % FORCESELFADJACENCY - sets main diagonal to 1s
            % Takes in matrix, sets main diagonal to 1s regardless of
            % previous values
            initialMainDiagonal = diag(inputMatrix);
            outputMatrix = inputMatrix - initialMainDiagonal + eye(size(inputMatrix));
        end
    end
end