classdef Hegselmann_Krause_Model < handle
    %Base Hegselmann-Krause model
    %   acts as superclass for other models
    properties (SetAccess = protected, GetAccess = public)
        time = 1  % time starts at 1 cuz 1-indexing
        timestep = 1

        n_agents {mustBePositive, mustBeInteger}  % number of agents
        c {mustBeNonnegative}  % confidence bound

        adjacency(:,:) % {mustBeA(adjacency,'logical')}  % original adjacency matrix
        original_opinions(:,1)  % original array matrix
    end

    properties (Access = protected)
        dist_matr(:,:)

        % modified adjacency matrix between agents
        % sets diagonal to 1 if all 0s
        adj_agents_matr(:,:)

        ind_matr(:,:) % {mustBeA(ind_matr,'logical')} % indicator matrix
        opinion_values(:,1)  % opinion values at current timestep
        simulation_data(:,:)  % opinion values at all timesteps
    end

    methods (Access = public)
        function self = Hegselmann_Krause_Model(bound, num_agents, adjacency, opinions)
            assert(size(adjacency) == [num_agents num_agents], "Adjacency matrix incompatible size.");
            assert(size(opinions) == [num_agents], "Opinion matrix incompatible size.");

            % set initial conditions
            self.c = bound;
            self.n_agents = num_agents;
            self.adjacency = adjacency;
            self.adj_agents_matr = fix_adjacency(adjacency);
            
            % opinions at t=0
            self.original_opinions = opinions;
            self.opinion_values = opinions;
            self.simulation_data(:,1) = opinions;
        end

        function simulate_steps(self, steps)
            for i = 2:steps
                % set distance and indicator matrices
                update_coefficients();

                self.simulation_data(:,i) = step(self.opinion_values);
            end

        end

        function simulate_duration(self, duration)
            simulate_steps(self, duration/self.timestep)
        end

        function data = get_data(self)
            data = self.simulation_data;
        end
    end

    methods (Access = protected)
        function new_opinions = step(self)
            % Kronecker delta at end of equation is already encoded in
            % modified adjacency matrix
            old_opinions = self.opinion_values;

            % element-wise multiplication for matrix determining whether
            % any given node influences another
            influence_matrix = self.adj_agents_matr.*self.ind_matr;

            % sum over columns (return row vector)
            new_opinions = sum(influence_matrix*old_opinions)/sum(influence_matrix);

            self.time = self.time + self.timestep;
        end

        function update_coefficients(self)
            % calculate opinion distance between all agents
            dist = distance(self.opinion_values);

            self.dist_matr = dist;
            self.ind_matr = dist <= self.c;
        end

        function dist = distance(self)
            dist = abs(self.ivec - vec.');
        end

        function new_adj = fix_adjacency(old_adj)
            if ~any(old_adj)
                new_adj = old_adj + eye(size(old_adj));
            else
                new_adj = old_adj;
            end
        end
    end

end
